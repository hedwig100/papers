# Cache 

## Abstract
私たちは、一貫性と単調性を要求するアプリケーション向けのキャッシュ方式である単調一貫キャッシュ（MCC: Monotonic Consistent Caching）を提案します。MCCは、トランザクションのようなリクエストに対して、常にバックエンドデータベースの一貫したビューを提供し、キャッシュ経由で観測された書き込みが失われることがないことを保証します。
MCCの計算の複雑性は、P時間（多項式時間）からNP完全に至るまで幅広く存在することを示します。私たちは、陳腐化アイテム（obsolete items）という概念に基づいてMCCを特徴づけ、それにより競争力のあるMCCポリシーを設計するための原則を抽象化しました。
この原則を応用し、事前にバッチ内のリクエストが知られているバッチモデルに対して、最適なMCCポリシーを開発しました。また、オンラインモデルおよびセミオンラインモデルにおいては、陳腐化アイテムの分類にブラックボックスな機械学習（ML）モデルを活用しつつ、たとえMLモデルがどれほど不正確でも理論的に競争力を保証できるML拡張型ポリシーを開発しました。
ベンチマークおよび実世界のトレースを用いた評価において、MCCポリシーはRedisとHBaseの構成におけるデータベース読み取りを39.09%削減し、スループットを77.15%向上させることを示しました。

## 1 はじめに
データ集約型のWebアプリケーションをサポートするために、Memcached [7] や Redis [8] のような外部データキャッシュをデータベースに追加することは一般的な手法となっています [21, 60, 62, 63, 75]。データアクセス要求をデータベースから外部キャッシュにリダイレクトすることで、バックエンドデータベースへの負荷を軽減し、システム全体のスループットを向上させることができます。

例 1: 図1に示すソーシャルメディアアプリケーションを考えます。ここで、アリスがボブのプロフィールに対して順番に読み取りリクエスト 𝑅1、𝑅3、𝑅4 を行う一方で、ボブはその間に書き込み 𝑊2 を実行してプロフィールを更新します（𝑅1と𝑅3の間で）。
初期状態では、データベース 𝐷 上のボブのプロフィールは以下の通りです：
(name: Bob, region: US, phone: 111, address: California)
アプリケーションサーバ 𝑀 は、**Redis キャッシュ C（容量は“無限”と仮定）**を使用しており、初期状態では空です。ルックアサイドキャッシング [41, 60, 66] に従って、𝑀 は 𝐷 と C の間を橋渡ししています。
𝑅1 に対して、アプリケーションサーバ 𝑀 は、データベース 𝐷 から name: Bob, region: US, address: California を取得してキャッシュ C に保存します。
その後、𝑀 は書き込み 𝑊2 によるキャッシュ無効化通知（ban [3] など）を受け取ります。これにより、キャッシュ内の region と address が古くなっていることが通知されます。
しかし、Redis のレイジー・エビクション戦略 [8] や ban プロトコルに従い、C は空き容量に困っていないため、それらのデータは削除されません。
続く 𝑅3 において：
name と region はキャッシュヒット、
phone はキャッシュミスとなります。
したがって、𝑀 は phone:222 をデータベース 𝐷 から取得し、C にキャッシュします。
一見すると、𝑅3 における全項目がキャッシュヒットになったように見えますが、アプリケーションの整合性ロジックにおいては問題が生じます。なぜなら、キャッシュ内の name: Bob, region: US と、新たに取得した phone:222 は整合性が取れておらず、データベース 𝐷 上に**（Bob, US, 222）という状態は存在しない**からです。
そのため、𝑀 は整合性のあるキャッシュヒットとするために、再度データベース 𝐷 から region: UK を取得し、C に追加します。これにより、𝑅3 の時点で name: Bob, region: UK, phone: 222 がキャッシュ内にそろい、整合性のあるキャッシュヒットとなります。
その後、𝑅4 はキャッシュ C 上で (Bob, US, California) に対する整合性のあるキャッシュヒットとなる可能性がありました。しかしながら、アリスはすでに 𝑅3 において region: UK を観測しており、𝑅4 で region: US を見せてしまうと、アリスの視点からは「地域情報が過去に戻る」ことになります。つまり、𝑀 がこの整合性のあるヒットをそのまま 𝑅4 に使った場合、アプリケーションロジック上、不整合が生じる可能性があります。
このため、𝑀 は address: London をデータベースから取得し、それを C にキャッシュして、𝑅4 が「整合性があり」「単調性もある」ビューを観測できるようにします。
□

例1に示されているように、キャッシュリクエストは複数の項目にアクセスすることがあります。このようなリクエストでは、たとえキャッシュヒットであっても、不整合（例：𝑅3）や非単調（例：𝑅4）なデータが含まれている場合には意味をなさない可能性があります。
実際、整合性とは、アプリケーションがある時点でのデータベースの一貫したビューを常に観測できることを意味し、単調性とは、一度観測した書き込みが失われることがないようにする性質です。これらの性質は、以下のようなアプリケーションにおいて**望まれる要件（desiderata）**として報告されています：
ソーシャルネットワーク [21, 25, 60, 70, 75]
ECサイト（電子商取引）[18, 26, 28, 73]
ストリーミングサービス [2, 15, 27, 34, 48, 69]
これまでの研究 [28, 38, 39, 41, 43, 53, 57, 63, 66] では、書き込みを追跡したり、アプリケーションに対して不整合なキャッシュヒットを通知するためのカスタマイズされたシステムやキャッシュ方式が開発されてきました。
しかし、それらは「不正なヒット（invalid hits）」に対してアプリケーション側のロジックで対処させたり、あるいはデフォルトで「キャッシュミスとして扱う」ような方法に頼ってきました。
この結果、キャッシュ内容の維持には2つの異なる独立した力が働くことになります：
(a) キャッシュ置換ポリシー（例：LRU）
　キャッシュが溢れた際に、どの項目を追い出すかを決定
(b) 不整合なキャッシュヒットに対する処理ロジック
　アプリケーションの意味論的要件に従わないヒットにどう対応するか
このように2つの力が独立して存在することは、従来のキャッシュ置換ポリシーの性能保証を損ね、最適とは言えないパフォーマンスを引き起こす原因となります。
実際、後述するように（セクション4）、伝統的に「最適」とされていたキャッシュポリシーは、もはや理想的ではなくなっていることが明らかになります。なぜなら、不正なキャッシュヒットへの対応との間に非自明な干渉が発生するからです。
さらに言えば、単調性という観点はこれまでの方式では考慮されておらず、特に複数項目へのアクセスを伴うリクエストに対しては未対応でした。

### 貢献
本研究では、以下の2つの貢献を通じて、この分野におけるギャップを埋めます：
(1) 一貫性および単調性の違反によって発生する不正なキャッシュヒットと、従来からあるキャッシュオーバーフローの両方を統合的に考慮するキャッシュポリシーを開発しました。これらのポリシーは理論的に競争力があり、場合によっては最適であることを証明しています。これは、キャッシュオーバーフローのみを最適化対象としていた従来のポリシーでは実現できなかったことです。
(2) これらのポリシーを実用化するために、MCCache というツールを開発しました。これは、Redis や Memcached といった既存のキャッシュシステムに対して内部実装を変更せずに導入可能であり、HBase 上でのスループットを平均で 77.15% 向上させることができます。

### MCCポリシー
私たちはまず、単調一貫キャッシュ（MCC: Monotonic Consistent Caching）を定式化しました。これは、キャッシュオーバーフローおよび一貫性や単調性を破ることによって発生する不正なキャッシュヒットの両方を統一的に扱う方式です。MCCにより、一貫性と単調性を考慮したキャッシュポリシーの有効性を明確に評価することが可能になります。
私たちは、従来の最適なキャッシュポリシーがもはや競争力を持たないことを示し、MCCのもとでの新しいキャッシュポリシー設計について理論的に検討しました。
MCCでは、これまでキャッシュ分野で用いられてきた**3つの入力モデル（バッチ・セミオンライン・オンライン）**すべてを対象とします：
バッチモデル：大量のリクエストがバッチ処理されるケースを抽象化します。これは、FacebookのMemcachedクラスター [60] や、トランザクションシステム [10] などで採用されています。リクエストは一時的にバッファに蓄積されてから処理されます。
セミオンラインモデル：読み取りリクエストはバッチとして事前に知られている一方で、書き込みリクエストは知られていないモデルです。典型例としては、Redisのセカンダリノード [9] が挙げられます。書き込みはキャッシュ無効化メッセージを通じてプライマリノードから伝播され、読み取りは通常通りローカルバッファでバッチ処理されます。
オンラインモデル：最も制約の少ないモデルで、読み取り・書き込みリクエストが逐次的に実行時に明らかになる形式です [21, 67, 68]。現実の多くのシステムがこのモデルに当てはまります。

### 計算量
私たちはMCCの計算量についても調査を行いました。結果として、最適なMCCキャッシュポリシーは一般にはNP完全（NP-Complete）であることを証明しました。これは、従来のキャッシュ問題（単にキャッシュミスによって溢れた際にどの項目を追い出すかを決める）では自明にP時間で解けるのとは対照的です [19]。
従来のキャッシュポリシーは、キャッシュミス時にどの項目を削除するかを決定すればよかったのに対して、MCCポリシーでは整合性が取れていない、または単調性を破るキャッシュヒットにも対応する必要があり、どのバージョンの項目をキャッシュに保持すべきかを判断しなければなりません。
私たちは、2つのバージョン選択戦略を検討します：**Eager（イーガー）とLazy（レイジー）**です。
ざっくり言えば、Lazy は一定の古さ（staleness）を許容してアイテムをキャッシュに保持する戦略であり、Redis のレイジー・エビクション戦略と一致します。一方、Eager は常に最新のアイテムを取得し、単調性を自動的に保証する戦略です。
驚くべきことに、MCCの計算複雑性は Eager と Lazy の選択によって大きく異なることが判明しました。具体的には：
**Eager 戦略を用いた場合、最適な MCC ポリシーは NP困難（NP-Hard）**であり、
Lazy 戦略では、最適な MCC ポリシーは多項式時間（Ptime）で解決可能となります。

特性の分析（Characterization）
私たちはさらに深く掘り下げ、単調性と一貫性がキャッシュに与える影響を明らかにします。その過程で、**「陳腐化アイテム（obsolete items）」**と呼ばれるキャッシュ内のデータ項目のクラスを特定しました。これにより、MCCポリシーの困難度がEagerとLazyでなぜ異なるのかが説明できます。
具体的には：
Lazy 戦略では、あるキャッシュ項目が陳腐化しているかどうかを判断するのは P時間（多項式時間）で可能ですが、
**Eager 戦略では、その判定は coNP-完全（coNP-Complete）**となります。
この特性に基づき、私たちはMCCポリシーを設計するための原則的なアプローチを開発しました。それは以下の命題（非形式的）に基づいています：
「あるキャッシュポリシー P が MCC に対して c-競争力（c-competitive）を持つならば、
まず陳腐化アイテムを優先的に削除し、その後は P とまったく同じように動作するポリシー 𝑃ₒ も、
少なくとも同じく c-競争力を持つ」
この命題により、既存の競争力あるポリシーに陳腐化対処ロジックを加えるだけで、依然として高い性能を保証できるという指針が得られます。

### 最適なポリシー
この原則を応用し、私たちは以下のような 最適なMCCポリシー を開発しました：
(a) バッチモデル向けのMCCポリシー：Lazy戦略において最適であることが保証されています。
(b) セミオンラインモデルおよびオンラインモデル向けのMCCポリシー：
これらは、陳腐化アイテムを判定するためのブラックボックスな機械学習分類器 M を取り込むことが可能です：
M が高精度な分類を行う場合、それを活用して性能を向上させることができます。
　その上で、オンラインモデルでは理論的に競争力が保証され、セミオンラインモデルでは最適性が保証されます。
さらに、これらのポリシーは **「MLロバスト（ML-robust）」**であり、
　たとえ M が悪意的に動作し、どれほど不正確な予測を出しても、依然として競争力を保ちます