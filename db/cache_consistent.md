# Cache 

## Abstract
私たちは、一貫性と単調性を要求するアプリケーション向けのキャッシュ方式である単調一貫キャッシュ（MCC: Monotonic Consistent Caching）を提案します。MCCは、トランザクションのようなリクエストに対して、常にバックエンドデータベースの一貫したビューを提供し、キャッシュ経由で観測された書き込みが失われることがないことを保証します。
MCCの計算の複雑性は、P時間（多項式時間）からNP完全に至るまで幅広く存在することを示します。私たちは、陳腐化アイテム（obsolete items）という概念に基づいてMCCを特徴づけ、それにより競争力のあるMCCポリシーを設計するための原則を抽象化しました。
この原則を応用し、事前にバッチ内のリクエストが知られているバッチモデルに対して、最適なMCCポリシーを開発しました。また、オンラインモデルおよびセミオンラインモデルにおいては、陳腐化アイテムの分類にブラックボックスな機械学習（ML）モデルを活用しつつ、たとえMLモデルがどれほど不正確でも理論的に競争力を保証できるML拡張型ポリシーを開発しました。
ベンチマークおよび実世界のトレースを用いた評価において、MCCポリシーはRedisとHBaseの構成におけるデータベース読み取りを39.09%削減し、スループットを77.15%向上させることを示しました。

## 1 はじめに
データ集約型のWebアプリケーションをサポートするために、Memcached [7] や Redis [8] のような外部データキャッシュをデータベースに追加することは一般的な手法となっています [21, 60, 62, 63, 75]。データアクセス要求をデータベースから外部キャッシュにリダイレクトすることで、バックエンドデータベースへの負荷を軽減し、システム全体のスループットを向上させることができます。

例 1: 図1に示すソーシャルメディアアプリケーションを考えます。ここで、アリスがボブのプロフィールに対して順番に読み取りリクエスト 𝑅1、𝑅3、𝑅4 を行う一方で、ボブはその間に書き込み 𝑊2 を実行してプロフィールを更新します（𝑅1と𝑅3の間で）。
初期状態では、データベース 𝐷 上のボブのプロフィールは以下の通りです：
(name: Bob, region: US, phone: 111, address: California)
アプリケーションサーバ 𝑀 は、**Redis キャッシュ C（容量は“無限”と仮定）**を使用しており、初期状態では空です。ルックアサイドキャッシング [41, 60, 66] に従って、𝑀 は 𝐷 と C の間を橋渡ししています。
𝑅1 に対して、アプリケーションサーバ 𝑀 は、データベース 𝐷 から name: Bob, region: US, address: California を取得してキャッシュ C に保存します。
その後、𝑀 は書き込み 𝑊2 によるキャッシュ無効化通知（ban [3] など）を受け取ります。これにより、キャッシュ内の region と address が古くなっていることが通知されます。
しかし、Redis のレイジー・エビクション戦略 [8] や ban プロトコルに従い、C は空き容量に困っていないため、それらのデータは削除されません。
続く 𝑅3 において：
name と region はキャッシュヒット、
phone はキャッシュミスとなります。
したがって、𝑀 は phone:222 をデータベース 𝐷 から取得し、C にキャッシュします。
一見すると、𝑅3 における全項目がキャッシュヒットになったように見えますが、アプリケーションの整合性ロジックにおいては問題が生じます。なぜなら、キャッシュ内の name: Bob, region: US と、新たに取得した phone:222 は整合性が取れておらず、データベース 𝐷 上に**（Bob, US, 222）という状態は存在しない**からです。
そのため、𝑀 は整合性のあるキャッシュヒットとするために、再度データベース 𝐷 から region: UK を取得し、C に追加します。これにより、𝑅3 の時点で name: Bob, region: UK, phone: 222 がキャッシュ内にそろい、整合性のあるキャッシュヒットとなります。
その後、𝑅4 はキャッシュ C 上で (Bob, US, California) に対する整合性のあるキャッシュヒットとなる可能性がありました。しかしながら、アリスはすでに 𝑅3 において region: UK を観測しており、𝑅4 で region: US を見せてしまうと、アリスの視点からは「地域情報が過去に戻る」ことになります。つまり、𝑀 がこの整合性のあるヒットをそのまま 𝑅4 に使った場合、アプリケーションロジック上、不整合が生じる可能性があります。
このため、𝑀 は address: London をデータベースから取得し、それを C にキャッシュして、𝑅4 が「整合性があり」「単調性もある」ビューを観測できるようにします。
□

例1に示されているように、キャッシュリクエストは複数の項目にアクセスすることがあります。このようなリクエストでは、たとえキャッシュヒットであっても、不整合（例：𝑅3）や非単調（例：𝑅4）なデータが含まれている場合には意味をなさない可能性があります。
実際、整合性とは、アプリケーションがある時点でのデータベースの一貫したビューを常に観測できることを意味し、単調性とは、一度観測した書き込みが失われることがないようにする性質です。これらの性質は、以下のようなアプリケーションにおいて**望まれる要件（desiderata）**として報告されています：
ソーシャルネットワーク [21, 25, 60, 70, 75]
ECサイト（電子商取引）[18, 26, 28, 73]
ストリーミングサービス [2, 15, 27, 34, 48, 69]
これまでの研究 [28, 38, 39, 41, 43, 53, 57, 63, 66] では、書き込みを追跡したり、アプリケーションに対して不整合なキャッシュヒットを通知するためのカスタマイズされたシステムやキャッシュ方式が開発されてきました。
しかし、それらは「不正なヒット（invalid hits）」に対してアプリケーション側のロジックで対処させたり、あるいはデフォルトで「キャッシュミスとして扱う」ような方法に頼ってきました。
この結果、キャッシュ内容の維持には2つの異なる独立した力が働くことになります：
(a) キャッシュ置換ポリシー（例：LRU）
　キャッシュが溢れた際に、どの項目を追い出すかを決定
(b) 不整合なキャッシュヒットに対する処理ロジック
　アプリケーションの意味論的要件に従わないヒットにどう対応するか
このように2つの力が独立して存在することは、従来のキャッシュ置換ポリシーの性能保証を損ね、最適とは言えないパフォーマンスを引き起こす原因となります。
実際、後述するように（セクション4）、伝統的に「最適」とされていたキャッシュポリシーは、もはや理想的ではなくなっていることが明らかになります。なぜなら、不正なキャッシュヒットへの対応との間に非自明な干渉が発生するからです。
さらに言えば、単調性という観点はこれまでの方式では考慮されておらず、特に複数項目へのアクセスを伴うリクエストに対しては未対応でした。

### 貢献
本研究では、以下の2つの貢献を通じて、この分野におけるギャップを埋めます：
(1) 一貫性および単調性の違反によって発生する不正なキャッシュヒットと、従来からあるキャッシュオーバーフローの両方を統合的に考慮するキャッシュポリシーを開発しました。これらのポリシーは理論的に競争力があり、場合によっては最適であることを証明しています。これは、キャッシュオーバーフローのみを最適化対象としていた従来のポリシーでは実現できなかったことです。
(2) これらのポリシーを実用化するために、MCCache というツールを開発しました。これは、Redis や Memcached といった既存のキャッシュシステムに対して内部実装を変更せずに導入可能であり、HBase 上でのスループットを平均で 77.15% 向上させることができます。

### MCCポリシー
私たちはまず、単調一貫キャッシュ（MCC: Monotonic Consistent Caching）を定式化しました。これは、キャッシュオーバーフローおよび一貫性や単調性を破ることによって発生する不正なキャッシュヒットの両方を統一的に扱う方式です。MCCにより、一貫性と単調性を考慮したキャッシュポリシーの有効性を明確に評価することが可能になります。
私たちは、従来の最適なキャッシュポリシーがもはや競争力を持たないことを示し、MCCのもとでの新しいキャッシュポリシー設計について理論的に検討しました。
MCCでは、これまでキャッシュ分野で用いられてきた**3つの入力モデル（バッチ・セミオンライン・オンライン）**すべてを対象とします：
バッチモデル：大量のリクエストがバッチ処理されるケースを抽象化します。これは、FacebookのMemcachedクラスター [60] や、トランザクションシステム [10] などで採用されています。リクエストは一時的にバッファに蓄積されてから処理されます。
セミオンラインモデル：読み取りリクエストはバッチとして事前に知られている一方で、書き込みリクエストは知られていないモデルです。典型例としては、Redisのセカンダリノード [9] が挙げられます。書き込みはキャッシュ無効化メッセージを通じてプライマリノードから伝播され、読み取りは通常通りローカルバッファでバッチ処理されます。
オンラインモデル：最も制約の少ないモデルで、読み取り・書き込みリクエストが逐次的に実行時に明らかになる形式です [21, 67, 68]。現実の多くのシステムがこのモデルに当てはまります。

### 計算量
私たちはMCCの計算量についても調査を行いました。結果として、最適なMCCキャッシュポリシーは一般にはNP完全（NP-Complete）であることを証明しました。これは、従来のキャッシュ問題（単にキャッシュミスによって溢れた際にどの項目を追い出すかを決める）では自明にP時間で解けるのとは対照的です [19]。
従来のキャッシュポリシーは、キャッシュミス時にどの項目を削除するかを決定すればよかったのに対して、MCCポリシーでは整合性が取れていない、または単調性を破るキャッシュヒットにも対応する必要があり、どのバージョンの項目をキャッシュに保持すべきかを判断しなければなりません。
私たちは、2つのバージョン選択戦略を検討します：**Eager（イーガー）とLazy（レイジー）**です。
ざっくり言えば、Lazy は一定の古さ（staleness）を許容してアイテムをキャッシュに保持する戦略であり、Redis のレイジー・エビクション戦略と一致します。一方、Eager は常に最新のアイテムを取得し、単調性を自動的に保証する戦略です。
驚くべきことに、MCCの計算複雑性は Eager と Lazy の選択によって大きく異なることが判明しました。具体的には：
**Eager 戦略を用いた場合、最適な MCC ポリシーは NP困難（NP-Hard）**であり、
Lazy 戦略では、最適な MCC ポリシーは多項式時間（Ptime）で解決可能となります。

特性の分析（Characterization）
私たちはさらに深く掘り下げ、単調性と一貫性がキャッシュに与える影響を明らかにします。その過程で、**「陳腐化アイテム（obsolete items）」**と呼ばれるキャッシュ内のデータ項目のクラスを特定しました。これにより、MCCポリシーの困難度がEagerとLazyでなぜ異なるのかが説明できます。
具体的には：
Lazy 戦略では、あるキャッシュ項目が陳腐化しているかどうかを判断するのは P時間（多項式時間）で可能ですが、
**Eager 戦略では、その判定は coNP-完全（coNP-Complete）**となります。
この特性に基づき、私たちはMCCポリシーを設計するための原則的なアプローチを開発しました。それは以下の命題（非形式的）に基づいています：
「あるキャッシュポリシー P が MCC に対して c-競争力（c-competitive）を持つならば、
まず陳腐化アイテムを優先的に削除し、その後は P とまったく同じように動作するポリシー 𝑃ₒ も、
少なくとも同じく c-競争力を持つ」
この命題により、既存の競争力あるポリシーに陳腐化対処ロジックを加えるだけで、依然として高い性能を保証できるという指針が得られます。

### 最適なポリシー
この原則を応用し、私たちは以下のような 最適なMCCポリシー を開発しました：
(a) バッチモデル向けのMCCポリシー：Lazy戦略において最適であることが保証されています。
(b) セミオンラインモデルおよびオンラインモデル向けのMCCポリシー：
これらは、陳腐化アイテムを判定するためのブラックボックスな機械学習分類器 M を取り込むことが可能です：
M が高精度な分類を行う場合、それを活用して性能を向上させることができます。
　その上で、オンラインモデルでは理論的に競争力が保証され、セミオンラインモデルでは最適性が保証されます。
さらに、これらのポリシーは **「MLロバスト（ML-robust）」**であり、
　たとえ M が悪意的に動作し、どれほど不正確な予測を出しても、依然として競争力を保ちます

### MCCache
私たちは、MCC（単調一貫キャッシュ）を既存のデータキャッシュに非侵襲的に追加するプラグイン型のシステム MCCache [6] を開発しました。
MCCache は、Redis や Memcached などのデータキャッシュが内部で用いているキャッシュポリシー（たいていは LRU 系）をバイパスし、専用の MCC キャッシュポリシーをその上で実行します。そして、基盤となるキャッシュが提供する削除操作（eviction operators）を通じて MCC の動作を注入します。

現在の MCCache の実装では、Redis や Memcached をはじめとする代表的なデータキャッシュに対応する組み込みコネクタを提供しています。

## たぶんここら辺なんか抜けてる

## 3. Preliminary

キャッシュと従来のキャッシュポリシーの基本を復習します.

### データベースのバージョン
データベース𝐷は、単純にデータ項目の集合 
`{d_1, d_2,..., d_n}`としてモデル化します。実際には、

- 読み込み: W[d_i] updates d_i in D
- 書き込み: R[d_i] returns d_i

書き込みがDの新しいバージョンを作る. D[i]をバージョンiのデータベースとする. d[j]をバージョンjでのアイテムdの値とする.

### キャッシュの基本、ポリシー
- キャッシュの説明
    - cache overflow
    - cache hit, miss
    - cache schedule: リクエスト列に対してどのアイテムを削除したかという動作のリスト
    - cache policy: cache scheduleをどう決めるかというアルゴリズムのこと, LRUが有名
    - stale: キャッシュの中にあるアイテムがどれくらい本当の値より古いかということ

## 3. Monotonic Consistent Caching
### Caching with Monotonicity and Consistency

- set-based requests `R: {d_1, ..., d_m}`: 複数のデータを堂宇時に読む読み出しクエリ、書き出しも同様に定義する.
- Consistency: 書き込みリクエストによって変化するデータベースDを考える。読み込みリクエスト`R = {d_1, ..., d_m}`がDでconsistencyをもつとはデータベースのバージョンlがあって、d_1,...,d_mがすべてD[l]に存在することをいう.
- Monotonicity:
    - 二つの読み込みリクエスト`R, R^\prime`に対して、`R`が`R^\prime` を先行するとは、`R`と`R^\prime`のいずれにも登場するどんなクエリ`d`に対しても、`d`が`R`を読んだとき`d[i]`, `d`が`R^\prime`を読んだときは`d[j]`だったとすると,`i \leq j`が成立することをいう.
    - `R_1, ..., R_n`を読みこみリクエストの列だとすると、`R_i`が単調であるとは任意の`R_l (l < i)`に対して、`R_l`が`R_i`を先行することをいう.
- Monotonic consistent caching
    - データベースDとそれに付随するキャッシュCを考える. T_iをReadもしくはWriteのリクエストとする. このとき読み出しリクエストは次の三つの可能性がある.
    1. Monotonic consistent cache hit: RがMCC hitであるとはCが`d_1[v_1], ..., d_m[v_m]` を持っていて,
        - あるデータベースのバージョン`D[l]`であって、`d_i[v_i] (i \in [1, m])`をすべて含むものがある
        - 列lのなかに`R`を先行するリクエスト`R^\prime`は存在しない、また`R`によって読まれるアイテム`d_i[v_i]`より新しいバージョン`d_i`を見ているリクエストも存在しない.
        - キャッシュされたd_iはstaleness boundを持つ.
    2. Non-MCC hit: RはC上でnon-MCCヒットであるとは、Cにアイテムd_iのコピーは存在するが, MCC hitではないもののことを言う.
    3. Cache miss: CがRのあるデータd_iを持っていないときにいう.
    これまではcache missとconsistencyは別に検討されていた、すなわちどのデータをevictするか決めるのにcache policyを決めて、もし取得したアイテムがconsistentでない場合にはアプリケーション側でアイテムをリフェッチすることで解決していた, この二つの問題を同時に考えるキャッシュポリシーがMCC policyである.
- MCC Schedules
    - 通常のキャッシュポリシーに加えて, non-MCCなhitsを防ぐためのアイテムの更新を行う. すなわちキャッシュの要領だけではなくてキャッシュヒットがconsistentになるように必要なアイテムのアップデートを行う.
- Version Selection
    - MCC hitとするために二つのバージョン選択戦略を考える.
    - (a) Eager: キャッシュされていない場合はDからもっとも最近のバージョンのアイテムを取得してキャッシュのアイテムをアップデートする.
    - (b) Lazy: リクエストRをMCC hitとできるもっとも古いバージョンを計算してそのバージョンのアイテムを取得する.

### Making Cache Monotonic and Consistent

- MCCache: MCC policyを実装したcache
- Input models: 
    - (a) Batch: すべての読み込み、書き込み列は事前に知られている.
    - (b) Semi-online: 読み込みリクエストは事前に知られているが、書き込みは知られていない.
    - (c) Online: すべての読み込み、書き込み列は未知.

## 4. Fundamental Study

### Complexity
- MCCP: 入力に対してフェッチコストを最小にするMCC policyを発見する問題.
- Complexity
    - DescitionバージョンでNP-complete
    - EagerストラテジーでNP-hard
    - LazyストラテジーでP

### Characterizations
- なぜMCCはそれほど複雑なのかを考察し、MCCポリシーをデザインする重要なアプローチを作る.
- Obsolete items: キャッシュC上で処理されるリクエスト列を考える. ある時間tにおいてキャッシュC上でアイテムdがobsoleteであるとは、時刻t以降の任意のリクエストにおいてdがどんなMCC scheduleであっても利用されないことと定義する.
- Principle: キャッシュオーバーフローが起きたら、obsoleteなアイテムから削除していく. 
    (1) obsoleteなアイテムを削除するというアプローチはスケジュールのコスト削減にあたり、どれくらい効果があるのでしょうか?: 
        - 毎回のリクエストの後にobsoleteなアイテムを削除すると実はnon-MCC hitsを無くすことができることが示せる.
    (2) obsoleteなアイテムの特定はどれくらい複雑なのでしょうか?:
        - Lazy戦略においてCのどのアイテムがobsoleteかどうか決定するのは多項式時間で可能.
        - Eager戦略においてはcoNP-completeな問題となる.

## 5. An optimal batch MCC policy
前章のprincpleからBatch設定において、Lazy戦略でもEager戦略でも動作するMCC policy: bMCPを示す. Lazy戦略においては最適性が示されている.

bMCPのアルゴリズムは以下のようになる.
1. MCC hitならP[R_i] is nil
2. non-MCC hitもしくはmissならば一致させるべきデータベースバージョンを決定
3. キャッシュ内のデータがデータベースバージョンと一致しないものはすべて取得
4. R_iに答えるのに必要な項目がキャッシュに存在しない場合はbMCPは次を実行.
    - obsoleteな項目をすべて削除
    - R_iに必要なキャッシュされていない項目をすべて取得
5. それでもキャッシュに空きがない場合はBeladyのルールを適用(つぎに参照されるのが最も遅いキャッシュから順に削除していく)

- データベースバージョンの決定
    - Eager: 最新
    - Lazy: キャッシュ内のデータについて以下のバージョンを記録しておく
        - x.minV: staleness制約のを満たしながら、xを含む最小のデータベースバージョン
        - x.lastV: リクエスト列においてRより前に現れたある読み取りリクエストR^\primeが最後に使用したキャッシュ内のxと同一バージョンを持つ最小のデータベースバージョン
        - Rに含まれ、かつキャッシュCに存在するデータxについての`max(x.minV, x.lastV)`の最大値

- obsolete itemsの特定
    - キャッシュCが無限の要領を持つと仮定して、dry-runすることでobsolete itemsを特定する.

- 上によりいかが示せる
    - 多項式時間
    - バッチモデルでbMCPはlazyおよびeager方式で単調性かつ整合性を満たす.
    - lazy方式ではobがobsolete itemsを見つけ出す.

## 6. Online policies with ml oracles
### A Robust Competitive Semi-Online Policy
### Extending to the Online Model

## 7. EXPERIMENTAL STUDY

